<policies>
    <inbound>
        <base />

        <!-- 1. Validate JWT from Entra External ID -->
        <!-- This ensures the user is authenticated -->
        <validate-jwt header-name="Authorization" failed-validation-httpcode="401" failed-validation-error-message="Invalid or expired JWT token">
            <openid-config url="https://mybartenderai.ciamlogin.com/a82813af-1054-4e2d-a8ec-c6b9c2908c91/v2.0/.well-known/openid-configuration" />
            <audiences>
                <audience>04551003-a57c-4dc2-97a1-37e0b3d1a2f6</audience>
            </audiences>
            <issuers>
                <issuer>https://mybartenderai.ciamlogin.com/a82813af-1054-4e2d-a8ec-c6b9c2908c91/v2.0</issuer>
            </issuers>
            <required-claims>
                <claim name="sub" />
                <!-- Require age verification claim -->
                <claim name="age_verified" match="all">
                    <value>true</value>
                </claim>
            </required-claims>
        </validate-jwt>

        <!-- 2. Validate APIM Subscription Key -->
        <!-- This is handled automatically by APIM when subscription-key is required on the product -->
        <!-- The Ocp-Apim-Subscription-Key header validation is automatic -->

        <!-- 3. Extract user ID from JWT for backend use -->
        <set-header name="X-User-Id" exists-action="override">
            <value>@{
                var jwt = context.Request.Headers.GetValueOrDefault("Authorization","").Replace("Bearer ", "");
                if (!string.IsNullOrEmpty(jwt))
                {
                    var parts = jwt.Split('.');
                    if (parts.Length == 3)
                    {
                        var payload = parts[1];
                        payload = payload.Replace('-', '+').Replace('_', '/');
                        switch (payload.Length % 4)
                        {
                            case 2: payload += "=="; break;
                            case 3: payload += "="; break;
                        }
                        var bytes = Convert.FromBase64String(payload);
                        var json = System.Text.Encoding.UTF8.GetString(bytes);
                        dynamic claims = Newtonsoft.Json.JsonConvert.DeserializeObject(json);
                        return claims?.sub?.ToString() ?? "unknown";
                    }
                }
                return "unknown";
            }</value>
        </set-header>

        <!-- 4. Add tier information from subscription -->
        <set-header name="X-User-Tier" exists-action="override">
            <value>@{
                var productId = context.Product?.Id ?? "unknown";
                if (productId.Contains("premium")) return "premium";
                if (productId.Contains("pro")) return "pro";
                if (productId.Contains("free")) return "free";
                return "unknown";
            }</value>
        </set-header>

        <!-- 5. Rate limiting by subscription (product-based) -->
        <!-- This is handled by Product quotas, not policy -->

        <!-- IMPORTANT: Do NOT delete Authorization header - backend needs it -->
        <!-- Previous policy had: <set-header name="Authorization" exists-action="delete" /> -->
        <!-- This broke the AI chat feature -->

    </inbound>
    <backend>
        <base />
    </backend>
    <outbound>
        <base />

        <!-- Remove sensitive headers from response -->
        <set-header name="X-User-Id" exists-action="delete" />
        <set-header name="X-User-Tier" exists-action="delete" />

        <!-- Add security headers -->
        <set-header name="X-Content-Type-Options" exists-action="override">
            <value>nosniff</value>
        </set-header>
        <set-header name="X-Frame-Options" exists-action="override">
            <value>DENY</value>
        </set-header>
    </outbound>
    <on-error>
        <base />

        <!-- Sanitize error responses to prevent information leakage -->
        <choose>
            <when condition="@(context.LastError.Source == "validate-jwt")">
                <return-response>
                    <set-status code="401" reason="Unauthorized" />
                    <set-header name="WWW-Authenticate" exists-action="override">
                        <value>Bearer realm="MyBartenderAI", error="invalid_token"</value>
                    </set-header>
                    <set-body>{"error": "Authentication required", "code": "AUTH_REQUIRED"}</set-body>
                </return-response>
            </when>
            <when condition="@(context.Response.StatusCode == 401)">
                <return-response>
                    <set-status code="401" reason="Unauthorized" />
                    <set-body>{"error": "Invalid or expired credentials", "code": "INVALID_CREDENTIALS"}</set-body>
                </return-response>
            </when>
            <when condition="@(context.Response.StatusCode == 403)">
                <return-response>
                    <set-status code="403" reason="Forbidden" />
                    <set-body>{"error": "Insufficient permissions for this operation", "code": "INSUFFICIENT_PERMISSIONS"}</set-body>
                </return-response>
            </when>
            <when condition="@(context.Response.StatusCode == 429)">
                <return-response>
                    <set-status code="429" reason="Too Many Requests" />
                    <set-body>{"error": "Rate limit exceeded. Please upgrade your plan or try again later.", "code": "RATE_LIMIT_EXCEEDED"}</set-body>
                </return-response>
            </when>
            <otherwise>
                <return-response>
                    <set-status code="500" reason="Internal Server Error" />
                    <set-body>{"error": "Service temporarily unavailable", "code": "SERVICE_ERROR"}</set-body>
                </return-response>
            </otherwise>
        </choose>
    </on-error>
</policies>